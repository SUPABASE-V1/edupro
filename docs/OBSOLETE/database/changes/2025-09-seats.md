# Teacher Seat Management Database Changes (September 2025)

## Overview

This document summarizes the database changes implemented for the teacher seat management system, including migrations, new functions, and rollback procedures.

## Migration Summary

The seat management system was implemented through a series of migrations that:

1. **Plan Normalization**: Added `teacher_seat_limit` column to subscription plans
2. **Seat Tracking**: Enhanced `subscription_seats` table with audit fields
3. **Security**: Implemented comprehensive RLS policies
4. **Utilities**: Added helper functions for authorization and locking
5. **Operations**: Created RPC functions for seat assignment and management

## Migration Details

### Migration A: Plan Teacher Seat Limits

**Purpose**: Establish canonical source of truth for plan seat limits

**Changes**:
```sql
-- Add seat limit column
ALTER TABLE public.subscription_plans 
ADD COLUMN IF NOT EXISTS teacher_seat_limit integer NULL;

-- Add constraint
ALTER TABLE public.subscription_plans
ADD CONSTRAINT plans_teacher_seat_limit_non_negative
CHECK (teacher_seat_limit IS NULL OR teacher_seat_limit >= 0);

-- Set plan limits (product-approved values)
UPDATE public.subscription_plans SET teacher_seat_limit = 1 WHERE name = 'free';
UPDATE public.subscription_plans SET teacher_seat_limit = 5 WHERE name = 'starter';  
UPDATE public.subscription_plans SET teacher_seat_limit = 15 WHERE name = 'premium';
UPDATE public.subscription_plans SET teacher_seat_limit = 100 WHERE name = 'enterprise';
```

**Impact**: Established teacher seat limits as primary source of truth for plan enforcement.

### Migration B: Subscription Seats Table Enhancement

**Purpose**: Add audit trail and status tracking to seat assignments

**Changes**:
```sql
-- Add audit columns if they don't exist
ALTER TABLE public.subscription_seats 
ADD COLUMN IF NOT EXISTS assigned_by uuid REFERENCES public.profiles(id) ON DELETE SET NULL,
ADD COLUMN IF NOT EXISTS revoked_at timestamptz NULL,
ADD COLUMN IF NOT EXISTS revoked_by uuid REFERENCES public.profiles(id) ON DELETE SET NULL,
ADD COLUMN IF NOT EXISTS is_active boolean GENERATED ALWAYS AS (revoked_at IS NULL) STORED;

-- Add indexes for performance
CREATE INDEX IF NOT EXISTS idx_subscription_seats_active 
ON public.subscription_seats(preschool_id) WHERE revoked_at IS NULL;

CREATE INDEX IF NOT EXISTS idx_subscription_seats_teacher 
ON public.subscription_seats(teacher_user_id);

-- Update existing records to set assigned_by for consistency
UPDATE public.subscription_seats 
SET assigned_by = teacher_user_id 
WHERE assigned_by IS NULL;
```

**Impact**: Enhanced tracking capabilities with full audit trail for seat assignments.

### Migration C: Row-Level Security Policies

**Purpose**: Implement strict tenant isolation and access controls

**Changes**:
```sql
-- Enable RLS
ALTER TABLE public.subscription_seats ENABLE ROW LEVEL SECURITY;

-- Principal read access policy
DROP POLICY IF EXISTS subscription_seats_select_principal ON public.subscription_seats;
CREATE POLICY subscription_seats_select_principal
ON public.subscription_seats
FOR SELECT
USING (
  EXISTS (
    SELECT 1 FROM public.profiles p
    WHERE p.id = auth.uid()
      AND p.preschool_id = subscription_seats.preschool_id
      AND p.role = 'principal'
  )
  OR
  subscription_seats.teacher_user_id = auth.uid()
);

-- Block all direct writes - force RPC usage
DROP POLICY IF EXISTS subscription_seats_block_writes ON public.subscription_seats;
CREATE POLICY subscription_seats_block_writes
ON public.subscription_seats
FOR ALL
TO public
USING (false)
WITH CHECK (false);
```

**Impact**: Secured table with multi-tenant isolation and role-based access control.

### Migration D: Helper Functions

**Purpose**: Provide utility functions for authorization and concurrency control

**Changes**:
```sql
-- Service role detection
CREATE OR REPLACE FUNCTION public.util_is_service_role()
RETURNS boolean
LANGUAGE sql
STABLE
AS $$
  SELECT coalesce((current_setting('request.jwt.claims', true)::jsonb->>'role') = 'service_role', false)
$$;

-- Principal school detection  
CREATE OR REPLACE FUNCTION public.util_caller_principal_school()
RETURNS uuid
LANGUAGE sql
STABLE
AS $$
  SELECT p.preschool_id
  FROM public.profiles p
  WHERE p.id = auth.uid() AND p.role = 'principal'
$$;

-- Advisory locking for concurrency control
CREATE OR REPLACE FUNCTION public.util_acquire_school_lock(p_school uuid)
RETURNS boolean
LANGUAGE sql
VOLATILE
AS $$
  SELECT pg_try_advisory_xact_lock(hashtext(p_school::text))
$$;
```

**Impact**: Provided foundation utilities for secure seat operations.

### Migration E: Seat Management RPCs

**Purpose**: Implement controlled seat assignment and revocation operations

**Changes**:
```sql
-- Assign seat RPC
CREATE OR REPLACE FUNCTION public.rpc_assign_teacher_seat(target_user_id uuid)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_is_service boolean := public.util_is_service_role();
  v_school uuid := public.util_caller_principal_school();
  v_limit int;
  v_used int;
BEGIN
  -- Authorization checks
  IF NOT v_is_service AND v_school IS NULL THEN
    RAISE EXCEPTION 'Only principals can assign teacher seats';
  END IF;

  -- Service role path - infer school from target
  IF v_is_service AND v_school IS NULL THEN
    SELECT preschool_id INTO v_school FROM public.profiles WHERE id = target_user_id;
    IF v_school IS NULL THEN
      RAISE EXCEPTION 'Cannot infer preschool for target user';
    END IF;
  END IF;

  -- Acquire lock for concurrency safety
  IF NOT public.util_acquire_school_lock(v_school) THEN
    RAISE EXCEPTION 'Seat assignment in progress; please retry';
  END IF;

  -- Verify target is teacher in same school
  PERFORM 1 FROM public.profiles
  WHERE id = target_user_id AND preschool_id = v_school AND role = 'teacher';
  IF NOT FOUND THEN
    RAISE EXCEPTION 'Target must be a teacher in the same preschool';
  END IF;

  -- Check for duplicate active seat
  PERFORM 1 FROM public.subscription_seats
  WHERE preschool_id = v_school AND teacher_user_id = target_user_id AND revoked_at IS NULL;
  IF FOUND THEN
    RETURN jsonb_build_object('status','already_assigned');
  END IF;

  -- Check plan limits
  SELECT sp.teacher_seat_limit INTO v_limit
  FROM public.subscriptions s
  JOIN public.subscription_plans sp ON sp.id = s.plan_id
  WHERE s.preschool_id = v_school
    AND s.status IN ('active','trialing')
  ORDER BY s.created_at DESC
  LIMIT 1;

  IF v_limit IS NOT NULL THEN
    SELECT count(*) INTO v_used
    FROM public.subscription_seats
    WHERE preschool_id = v_school AND revoked_at IS NULL;

    IF v_used >= v_limit THEN
      RAISE EXCEPTION 'No teacher seats available for this plan';
    END IF;
  END IF;

  -- Create seat assignment
  INSERT INTO public.subscription_seats (preschool_id, teacher_user_id, assigned_by)
  VALUES (v_school, target_user_id, coalesce(auth.uid(), target_user_id));

  RETURN jsonb_build_object('status','assigned');
END;
$$;

-- Revoke seat RPC
CREATE OR REPLACE FUNCTION public.rpc_revoke_teacher_seat(target_user_id uuid)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_is_service boolean := public.util_is_service_role();
  v_school uuid := public.util_caller_principal_school();
BEGIN
  -- Authorization checks
  IF NOT v_is_service AND v_school IS NULL THEN
    RAISE EXCEPTION 'Only principals can revoke teacher seats';
  END IF;

  -- Service role path
  IF v_is_service AND v_school IS NULL THEN
    SELECT preschool_id INTO v_school FROM public.profiles WHERE id = target_user_id;
  END IF;

  -- Acquire lock
  IF NOT public.util_acquire_school_lock(v_school) THEN
    RAISE EXCEPTION 'Seat update in progress; please retry';
  END IF;

  -- Revoke seat
  UPDATE public.subscription_seats
  SET revoked_at = now(),
      revoked_by = coalesce(auth.uid(), target_user_id)
  WHERE preschool_id = v_school
    AND teacher_user_id = target_user_id
    AND revoked_at IS NULL;

  IF NOT FOUND THEN
    RETURN jsonb_build_object('status','no_active_seat');
  END IF;

  RETURN jsonb_build_object('status','revoked');
END;
$$;

-- Seat limits query RPC  
CREATE OR REPLACE FUNCTION public.rpc_teacher_seat_limits()
RETURNS TABLE(limit int, used int, available int)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_school uuid := public.util_caller_principal_school();
  v_limit int;
  v_used int;
BEGIN
  IF v_school IS NULL AND NOT public.util_is_service_role() THEN
    SELECT preschool_id INTO v_school FROM public.profiles WHERE id = auth.uid();
  END IF;

  IF v_school IS NULL THEN
    RAISE EXCEPTION 'Cannot determine preschool for caller';
  END IF;

  -- Get plan limit
  SELECT sp.teacher_seat_limit INTO v_limit
  FROM public.subscriptions s
  JOIN public.subscription_plans sp ON sp.id = s.plan_id
  WHERE s.preschool_id = v_school
    AND s.status IN ('active','trialing')
  ORDER BY s.created_at DESC
  LIMIT 1;

  -- Count active seats
  SELECT count(*) INTO v_used
  FROM public.subscription_seats
  WHERE preschool_id = v_school AND revoked_at IS NULL;

  RETURN QUERY
  SELECT v_limit,
         v_used,
         CASE WHEN v_limit IS NULL THEN NULL ELSE GREATEST(v_limit - v_used, 0) END AS available;
END;
$$;

-- List seats RPC
CREATE OR REPLACE FUNCTION public.rpc_list_teacher_seats()
RETURNS TABLE(id uuid, teacher_user_id uuid, assigned_at timestamptz, revoked_at timestamptz)
LANGUAGE plpgsql
SECURITY DEFINER  
SET search_path = public
AS $$
DECLARE
  v_school uuid := public.util_caller_principal_school();
  v_caller uuid := auth.uid();
BEGIN
  IF v_school IS NOT NULL THEN
    -- Principal: return all seats for their school
    RETURN QUERY
    SELECT ss.id, ss.teacher_user_id, ss.assigned_at, ss.revoked_at
    FROM public.subscription_seats ss
    WHERE ss.preschool_id = v_school;
  END IF;

  -- Teacher: return only own seats
  RETURN QUERY
  SELECT ss.id, ss.teacher_user_id, ss.assigned_at, ss.revoked_at
  FROM public.subscription_seats ss
  WHERE ss.teacher_user_id = v_caller;
END;
$$;
```

**Impact**: Provided secure, controlled seat operations with proper authorization and concurrency protection.

## Data Validation

### Same-School Constraint Trigger

```sql
CREATE OR REPLACE FUNCTION public.trg_subscription_seats_validate_same_school()
RETURNS trigger
LANGUAGE plpgsql
AS $$
DECLARE
  v_teacher_school uuid;
  v_teacher_role text;
BEGIN
  SELECT preschool_id, role
  INTO v_teacher_school, v_teacher_role
  FROM public.profiles
  WHERE id = new.teacher_user_id;

  IF v_teacher_school IS NULL THEN
    RAISE EXCEPTION 'Teacher profile not found';
  END IF;

  IF v_teacher_school <> new.preschool_id THEN
    RAISE EXCEPTION 'Teacher must belong to the same preschool';
  END IF;

  IF v_teacher_role IS DISTINCT FROM 'teacher' THEN
    RAISE EXCEPTION 'Target user must have role teacher';
  END IF;

  RETURN new;
END $$;

CREATE TRIGGER trg_subscription_seats_validate_same_school
BEFORE INSERT OR UPDATE ON public.subscription_seats
FOR EACH ROW EXECUTE PROCEDURE public.trg_subscription_seats_validate_same_school();
```

## Performance Considerations

### Indexes Added
- `idx_subscription_seats_active`: Fast lookup of active seats per school
- `idx_subscription_seats_teacher`: Fast lookup by teacher ID

### Query Optimization
- Used partial indexes for frequently filtered columns
- Advisory locks prevent concurrent modification issues
- SECURITY DEFINER functions reduce RLS overhead

## Testing & Verification

### Migration Validation Commands
```bash
# Verify no schema drift
supabase db diff

# Test seat assignment
SELECT rpc_assign_teacher_seat('teacher-uuid');

# Test seat limits
SELECT * FROM rpc_teacher_seat_limits();

# Test seat listing  
SELECT * FROM rpc_list_teacher_seats();
```

### Data Integrity Checks
```sql
-- Verify all active seats have valid teachers
SELECT s.*, p.role, p.preschool_id
FROM subscription_seats s
JOIN profiles p ON p.id = s.teacher_user_id  
WHERE s.revoked_at IS NULL
  AND p.role != 'teacher';

-- Verify seat counts don't exceed limits
SELECT 
  s.preschool_id,
  COUNT(*) as active_seats,
  sp.teacher_seat_limit
FROM subscription_seats s
JOIN subscriptions sub ON sub.preschool_id = s.preschool_id
JOIN subscription_plans sp ON sp.id = sub.plan_id
WHERE s.revoked_at IS NULL
  AND sub.status IN ('active','trialing')
GROUP BY s.preschool_id, sp.teacher_seat_limit
HAVING sp.teacher_seat_limit IS NOT NULL 
   AND COUNT(*) > sp.teacher_seat_limit;
```

## Rollback Procedures

### Emergency Rollback (If Required)

**⚠️ WARNING**: Only execute rollback procedures with proper authorization and backup verification.

```sql
-- Step 1: Disable new seat assignments (safeguard)
REVOKE EXECUTE ON FUNCTION rpc_assign_teacher_seat FROM authenticated, anon;

-- Step 2: Remove RPC functions (if needed)
DROP FUNCTION IF EXISTS public.rpc_assign_teacher_seat;
DROP FUNCTION IF EXISTS public.rpc_revoke_teacher_seat;  
DROP FUNCTION IF EXISTS public.rpc_teacher_seat_limits;
DROP FUNCTION IF EXISTS public.rpc_list_teacher_seats;

-- Step 3: Remove utility functions (if needed)
DROP FUNCTION IF EXISTS public.util_is_service_role;
DROP FUNCTION IF EXISTS public.util_caller_principal_school; 
DROP FUNCTION IF EXISTS public.util_acquire_school_lock;

-- Step 4: Remove RLS policies (DANGEROUS - removes security)
-- Only if absolutely necessary
DROP POLICY IF EXISTS subscription_seats_select_principal ON public.subscription_seats;
DROP POLICY IF EXISTS subscription_seats_block_writes ON public.subscription_seats;
ALTER TABLE public.subscription_seats DISABLE ROW LEVEL SECURITY;

-- Step 5: Remove audit columns (DESTRUCTIVE - loses data)
-- Only if reverting completely
ALTER TABLE public.subscription_seats 
DROP COLUMN IF EXISTS assigned_by,
DROP COLUMN IF EXISTS revoked_at,
DROP COLUMN IF EXISTS revoked_by,
DROP COLUMN IF EXISTS is_active;

-- Step 6: Remove plan limits (DESTRUCTIVE)
ALTER TABLE public.subscription_plans DROP COLUMN IF EXISTS teacher_seat_limit;
```

### Partial Rollback Options

**Disable Feature Only** (Preserve Data):
```sql
-- Just disable the RPCs while keeping data intact
REVOKE EXECUTE ON FUNCTION rpc_assign_teacher_seat FROM authenticated, anon;
REVOKE EXECUTE ON FUNCTION rpc_revoke_teacher_seat FROM authenticated, anon;
```

**Restore Previous Function Versions**:
Use migration repair to restore to previous state while preserving data.

## Migration Log

| Migration | Status | Applied | Rollback Available |
|-----------|--------|---------|-------------------|
| Plan Seat Limits | ✅ Applied | 2025-09-20 | ✅ Yes |
| Subscription Seats Enhancement | ✅ Applied | 2025-09-20 | ⚠️ Partial |
| RLS Policies | ✅ Applied | 2025-09-20 | ✅ Yes |
| Helper Functions | ✅ Applied | 2025-09-20 | ✅ Yes |
| Seat RPCs | ✅ Applied | 2025-09-20 | ✅ Yes |

## Monitoring

### Key Metrics to Monitor
- Seat assignment success/failure rates
- Plan limit violations
- RPC performance (< 100ms typical)
- Lock contention incidents
- RLS policy violations

### Log Analysis Queries
```sql
-- Recent seat assignments
SELECT * FROM subscription_seats 
WHERE assigned_at > NOW() - INTERVAL '24 hours'
ORDER BY assigned_at DESC;

-- Seat utilization by school
SELECT 
  preschool_id,
  COUNT(*) as active_seats,
  MAX(assigned_at) as last_assignment
FROM subscription_seats 
WHERE revoked_at IS NULL
GROUP BY preschool_id
ORDER BY active_seats DESC;
```

## References

- [Security Documentation](/docs/security/seats.md)
- [Architecture Documentation](/docs/architecture/billing-and-plans.md)  
- [WARP.md Database Guidelines](/docs/governance/WARP.md#database-operations)

## Contact

For questions about these database changes:
- Security Review: Security Lead
- Schema Changes: Database Team  
- Rollback Authorization: Change Advisory Board